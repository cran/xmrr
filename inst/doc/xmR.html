<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Introduction</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Introduction</h1>

<p>XMR control charts are useful when determining if there are significant trends in data. XMR charts have two key assumptions: one is that the measurements of value happen over time, and the other is that each measurement of time has exactly one measurement of value. </p>

<p>Take careful thought about <em>what</em> you are trying to measure with XMR. Proportions work great, headcount is okay, costs over time don&#39;t work well.</p>

<hr/>

<h1>Arguments</h1>

<p>The arguments for <code>xmr()</code> are: </p>

<ul>
<li><p><strong>df</strong>: The dataframe containing the time-series data.</p></li>
<li><p><strong>measure</strong>: The column containing the measure. This must be in a numeric format.</p></li>
<li><p><strong>interval</strong>: The interval you&#39;d like to use to calculate the averages. Defaults to 5.</p></li>
<li><p><strong>recalc</strong>: Logical if you&#39;d like it to recalculate bounds. Defaults to False for safety.</p></li>
<li><p><strong>reuse</strong>: Logical: Should points be re-used in calculations? Defaults to False.</p></li>
<li><p><strong>longrun</strong>: A vector of 2 to determine the rules for a long run. The first point is the &#39;n&#39; of points used to calculate the new reference lines, and the second is to determine how many consecutive points are needed to define a longrun. Default is c(5,8) which uses the first 5 points of a run of 8 to recalculate the bounds. </p></li>
<li><p><strong>shortrun</strong>: A vector of 2 to determine the rules for a short run. The first point is the minimum number of points within the set to qualify a shortrun, and the second is the length of a possible set. Default is c(3,4) which states that 3 of 4 consecutive points need to pass the test to be used in a calculation. </p></li>
</ul>

<p>The data required for XMR charts take a specific format, with at least two columns of data - one for the time variable and another for the measurement. </p>

<p>Like so:</p>

<table><thead>
<tr>
<th align="center">Time</th>
<th align="center">Measure</th>
</tr>
</thead><tbody>
<tr>
<td align="center">2000</td>
<td align="center">54</td>
</tr>
<tr>
<td align="center">2001</td>
<td align="center">56</td>
</tr>
<tr>
<td align="center">2002</td>
<td align="center">59</td>
</tr>
<tr>
<td align="center">2003</td>
<td align="center">65</td>
</tr>
<tr>
<td align="center">2004</td>
<td align="center">53</td>
</tr>
<tr>
<td align="center">2005</td>
<td align="center">64</td>
</tr>
<tr>
<td align="center">2006</td>
<td align="center">65</td>
</tr>
<tr>
<td align="center">2007</td>
<td align="center">61</td>
</tr>
<tr>
<td align="center">2008</td>
<td align="center">60</td>
</tr>
<tr>
<td align="center">2009</td>
<td align="center">51</td>
</tr>
<tr>
<td align="center">2010</td>
<td align="center">53</td>
</tr>
<tr>
<td align="center">2011</td>
<td align="center">53</td>
</tr>
<tr>
<td align="center">2012</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">2013</td>
<td align="center">76</td>
</tr>
<tr>
<td align="center">2014</td>
<td align="center">82</td>
</tr>
<tr>
<td align="center">2015</td>
<td align="center">77</td>
</tr>
<tr>
<td align="center">2016</td>
<td align="center">81</td>
</tr>
<tr>
<td align="center">2017</td>
<td align="center">85</td>
</tr>
</tbody></table>

<p>If we wanted to use <code>xmr()</code> on this data would be written like this: </p>

<pre><code class="r">xmr_data &lt;- xmr(df = example_data, measure = &quot;Measure&quot;)
</code></pre>

<p>And if we wanted the bounds to recalculate, we&#39;d use this.</p>

<pre><code class="r">xmr_data &lt;- xmr(df = example_data, measure = &quot;Measure&quot;, recalc = T)
</code></pre>

<p>Output data looks like this:</p>

<p>The only mandatory arguments are <strong>df</strong>, because the function needs to operate on a dataframe, and <strong>measure</strong> because the function needs to be told which column contains the measurements. Everything else has been set to what I believe is a safe and sensible default. </p>

<p>In our shop, we typically run the following rules. Since they are the default, there is no need to specify them directly:</p>

<pre><code class="r">xmr_data &lt;- xmr(example_data,  &quot;Measure&quot;, 
                recalc = T,
                interval = 5,
                shortrun = c(3,4),
                longrun = c(5,8))
</code></pre>

<p>Feel free to play around with your own definitions of what a shortrun or longrun is.</p>

<pre><code class="r">xmr_data &lt;- xmr(df = example_data, 
                measure = &quot;Measure&quot;, 
                recalc = T,
                #change the rule like so:,
                interval = 4,
                shortrun = c(2,3))
</code></pre>

<p>The statistical differences between rules are slight, but each user will have different needs and it&#39;s useful to be able to tune the function to those needs. </p>

<p>It is important to use a consistent definition of what a long/short run are. It wouldn&#39;t be appropriate in one report to use one set of definitions for one dataset, and another set for a different dataset.</p>

<hr/>

<h1>Charts</h1>

<p>The <code>xmr()</code> function is handy for generating chart data as the output can be saved and used in other applications. But what about visualization within R?</p>

<p><code>xmr_chart()</code> takes the output from <code>xmr()</code> and generates a ggplot graphic. This works well for reporting, but it also works great for quick diagnostics of your data.</p>

<p>The arguments for <code>xmr_chart()</code> are: </p>

<ul>
<li><p><strong>dataframe</strong>: Output from xmr()</p></li>
<li><p><strong>time</strong>: The column containing the time variable for the x-axis.</p></li>
<li><p><strong>measure</strong>: The column containing the measure for the y-axis. </p></li>
<li><p><strong>boundary_linetype</strong>: Type of line for upper and lower boundary lines. Defaults to &ldquo;dashed&rdquo;.</p></li>
<li><p><strong>central_linetype</strong>: Type of line for central line. Defaults to &ldquo;dotted&rdquo;.</p></li>
<li><p><strong>boundary_colour</strong>:  Colour of line for upper and lower boundary lines. Defaults to &ldquo;#d02b27&rdquo;.</p></li>
<li><p><strong>point_colour</strong>: Colour of points. Defaults to &ldquo;#7ECBB5&rdquo;.</p></li>
<li><p><strong>point_size</strong>:   Size of points. Defaults to 2.</p></li>
<li><p><strong>line_width</strong>:   Width of lines. Defaults to 0.5.</p></li>
<li><p><strong>text_size</strong>:    Size of chart text. Defaults to 9.</p></li>
</ul>

<p>There are defaults set for most arguments, so all the user <em>needs</em> to supply are the column names for the Time and Measurement column unless they want some slight modification of the default chart.</p>

<pre><code class="r">xmr_chart(xmr_data, 
          time = &quot;Time&quot;, 
          measure = &quot;Measure&quot;,
          line_width = 0.75, text_size = 12, point_size = 2.5)
</code></pre>

<p>A work-flow that I use is to &#39;pipe&#39; the output of <code>xmr()</code> directly into <code>xmr_chart()</code>:</p>

<pre><code class="r">example_data %&gt;% 
  xmr(&quot;Measure&quot;, recalc = T) %&gt;% 
  xmr_chart(&quot;Time&quot;, &quot;Measure&quot;)
</code></pre>

<hr/>

<h1>Tidyverse - dplyr &amp; ggplot2</h1>

<p>Simple datasets like those illustrated above are common, but how could we work with large datasets that have multiple factors?</p>

<p>Consider the following data. How would <code>xmr()</code> benefit the user in this case? </p>

<table><thead>
<tr>
<th align="center">Year</th>
<th align="center">Variable</th>
<th align="center">Measure</th>
</tr>
</thead><tbody>
<tr>
<td align="center">2004</td>
<td align="center">A</td>
<td align="center">38</td>
</tr>
<tr>
<td align="center">2005</td>
<td align="center">A</td>
<td align="center">78</td>
</tr>
<tr>
<td align="center">2006</td>
<td align="center">A</td>
<td align="center">93</td>
</tr>
<tr>
<td align="center">2007</td>
<td align="center">A</td>
<td align="center">21</td>
</tr>
<tr>
<td align="center">2008</td>
<td align="center">A</td>
<td align="center">65</td>
</tr>
<tr>
<td align="center">2009</td>
<td align="center">A</td>
<td align="center">13</td>
</tr>
<tr>
<td align="center">2010</td>
<td align="center">A</td>
<td align="center">27</td>
</tr>
<tr>
<td align="center">2011</td>
<td align="center">A</td>
<td align="center">39</td>
</tr>
<tr>
<td align="center">2012</td>
<td align="center">A</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2013</td>
<td align="center">A</td>
<td align="center">38</td>
</tr>
<tr>
<td align="center">2014</td>
<td align="center">A</td>
<td align="center">87</td>
</tr>
<tr>
<td align="center">2015</td>
<td align="center">A</td>
<td align="center">34</td>
</tr>
<tr>
<td align="center">2016</td>
<td align="center">A</td>
<td align="center">48</td>
</tr>
<tr>
<td align="center">2017</td>
<td align="center">A</td>
<td align="center">60</td>
</tr>
<tr>
<td align="center">2004</td>
<td align="center">B</td>
<td align="center">49</td>
</tr>
<tr>
<td align="center">2005</td>
<td align="center">B</td>
<td align="center">19</td>
</tr>
<tr>
<td align="center">2006</td>
<td align="center">B</td>
<td align="center">83</td>
</tr>
<tr>
<td align="center">2007</td>
<td align="center">B</td>
<td align="center">67</td>
</tr>
<tr>
<td align="center">2008</td>
<td align="center">B</td>
<td align="center">79</td>
</tr>
<tr>
<td align="center">2009</td>
<td align="center">B</td>
<td align="center">11</td>
</tr>
<tr>
<td align="center">2010</td>
<td align="center">B</td>
<td align="center">72</td>
</tr>
<tr>
<td align="center">2011</td>
<td align="center">B</td>
<td align="center">41</td>
</tr>
<tr>
<td align="center">2012</td>
<td align="center">B</td>
<td align="center">82</td>
</tr>
<tr>
<td align="center">2013</td>
<td align="center">B</td>
<td align="center">65</td>
</tr>
<tr>
<td align="center">2014</td>
<td align="center">B</td>
<td align="center">78</td>
</tr>
<tr>
<td align="center">2015</td>
<td align="center">B</td>
<td align="center">55</td>
</tr>
<tr>
<td align="center">2016</td>
<td align="center">B</td>
<td align="center">53</td>
</tr>
<tr>
<td align="center">2017</td>
<td align="center">B</td>
<td align="center">79</td>
</tr>
</tbody></table>

<p>The answer is by leveraging other R packages, namely the <code>tidyverse</code>. </p>

<p>You can install and load the tidyverse with: </p>

<pre><code class="r">#this installs many useful packages
install.packages(&quot;tidyverse&quot;)

#this just loads the ones we need
library(dplyr)
library(purrr)
library(ggplot2)
</code></pre>

<p>With <code>dplyr</code>, we can make use of powerful data-wrangling verbs without writing them into <code>xmrr</code>&#39;s functions specifically:</p>

<ul>
<li><code>select()</code>:-  picks variables based on their names.</li>
<li><code>filter()</code>:-  picks cases based on their values.</li>
<li><code>arrange()</code>:- changes the ordering of the rows.</li>
<li><code>mutate()</code>:-  adds new variables that are functions of existing variables.</li>
<li><code>summarise()</code>:-   reduces multiple values down to a single summary.</li>
<li><code>group_by()</code>:-    allows for group operations in the &ldquo;split-apply-combine&rdquo; concept</li>
</ul>

<p>Also loaded with <code>dplyr</code> is a powerful operator to chain functions together, called a pipe <code>%&gt;%</code>. </p>

<p>With <code>ggplot2</code>, we take a modern approach to visualizing data. An up-to-date reference list of functions can be found <a href="http://ggplot2.tidyverse.org/reference/">here</a></p>

<p>This enables a number of verb-type functions for tidying, wrangling, and plotting data. This is how to use them alongside the <code>xmr()</code> and <code>xmr_chart()</code> functions. </p>

<hr/>

<h1>Grouping and Faceting</h1>

<p>Take our multiple factor data <code>MFD</code> - here is how to apply the <code>xmr()</code> function to certain groups within that data. </p>

<pre><code class="r">MFD_xmr &lt;- MFD %&gt;% 
  group_split(Variable)  %&gt;% 
  map(xmr, measure = &quot;Measure&quot;, recalc = T) %&gt;%
  map_df(as_tibble)
</code></pre>

<p>To obtain the following:</p>

<p>And as you may be able to see in the data, the <code>xmr()</code> calculated on Measure <strong>BY</strong> Variable in one chained function instead of having to manually split the data and run the function multiple times. This is possible with an arbitrary number of factors, and leverages the speed of <code>dplyr</code> verbs. </p>

<p>Similarly, <code>ggplot2</code> can be leveraged in plotting. Note that since <code>xmr_chart()</code> outputs a ggplot object, we can apply the regular ggplot2 functions to it and return a faceted chart rather than filtering the chart and making two.</p>

<pre><code class="r">MFD_xmr %&gt;% 
  xmr_chart(&quot;Year&quot;, &quot;Measure&quot;, line_width = 0.75, text_size = 12) + 
  facet_wrap(~Variable) + 
  scale_x_discrete(breaks = seq(2004, 2017, 4))
</code></pre>

</body>

</html>
